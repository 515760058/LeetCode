剑指 Offer 56 - I. 数组中数字出现的次数
/*
相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。
所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。

假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的
那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。
这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。
这两个数组里面的数各自进行异或，得到的结果就是答案
*/
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int num = 0; // 所有数的异或结果
        for (int n : nums) {
            num ^= n;
        }
        // 从右向左找第一个比特1，也就是第idx位 从而将所有的数字分为两组
        int idx = 0;
        while (num) {
            if (num & 0x1) {
                break;
            }
            idx++;
            num >>= 1;
        }
        // 根据idx位的比特1  将所有数据分为两组
        int res1 = 0;
        int res2 = 0;
        for (int n : nums) {
            if ((n >> idx) & 0x1) {
                res1 ^= n;
            } else {
                res2 ^= n;
            }
        }
        return {res1, res2};
    }
};


剑指 Offer 56 - II. 数组中数字出现的次数 II
/*
如果一个数字出现3次，它的二进制每一位也出现的3次。
如果把所有的出现三次的数字的二进制表示的每一位都分别加起来，那么每一位都能被3整除。
我们把数组中所有的数字的二进制表示的每一位都加起来。
    如果某一位能被3整除，那么这一位对只出现一次的那个数的这一肯定为0。
    如果某一位不能被3整除，那么只出现一次的那个数字的该位置一定为1.
*/
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector<int> m(32, 0); // int是32位的  所有数字中每个比特位1 出现的总次数
        for (int num : nums) {
            for (int i = 0; i < 32; ++i) {
                m[i] += ((num>>i) & 0x1); // 统计次数
            }
        }
        int res = 0;
        for (int i= 0; i < m.size(); ++i) {
            res |= ((1<<i) * (m[i]%3)); // 还原数字
        }
        return res;
    }
};

