8. 字符串转换整数 (atoi)   剑指 Offer 67. 把字符串转换成整数
class Solution {
public:
    int myAtoi(string str) {
        int i = 0;// 找到有意义的起始下标
        while (i < str.size() && str[i] == ' '){//找到第一个非空格的字符
            ++i;
        }
        if (i == str.size()){ // 全是空格
            return 0;
        }

        int flag = 1; // 记录正负符号
        if (str[i] == '-') { // 负号
            flag = -1;
            ++i;
        }else if (str[i] == '+') { // 正号
            flag = 1;
            ++i;
        }
        // 处理数字部分
        long res = 0;
        for (; i < str.size() && isdigit(str[i]); ++i) { // isdigit(str[i]) '0' ~ '9'
            res = res * 10 + (str[i] - '0'); // 数字部分
            if (flag == 1 && res >= INT_MAX) { // 数字部分 超过正数的上限
                return INT_MAX;
            }
            if (flag == -1 && res > INT_MAX) { // 数字部分 达到负数的上限
                return INT_MIN;
            }
        } 
        return flag * res;
    }
};






392. 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0; // 对应t的下标
        int j = 0; // 对应s的下标
        while (i < t.size()){
            if (j == s.size()) {
                return true;
            } else if (t[i] == s[j]) { // 字母相同
                i++;
                j++;
            } else{
                i++;
            }   
        }
        return j == s.size();
    }
};


5. 最长回文子串
给你一个字符串 s，找到 s 中最长的回文子串。
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for (int i = 0; i < s.size(); ++i) {
            string s1 = getPalindrome(s, i, i);   // 回文串的长度是奇数 有一个字符是中心
            string s2 = getPalindrome(s, i, i+1); // 回文串的长度是偶数 没有中心字符
            if (s1.size() > res.size()) { res = s1; }
            if (s2.size() > res.size()) { res = s2; }
        }
        return res;
    }

private:
    // 以s[l]和s[r]为中心，向两侧扩展 寻找回文子串
    string getPalindrome(string& s, int l, int r) {
        while (l >= 0 && r < s.size() && s[l] == s[r]) {
            // 向两边扩展
            l--;
            r++;
        }
        // 返回以s[l]和s[r]为中心的回文子串
        return s.substr(l+1, r-l-1);
    }
};



415. 字符串相加
class Solution {
public:
    string addStrings(string num1, string num2) {
        int size = max(num1.size(), num2.size());
        //在短的字符串前面补0，以此把数位“对齐”
        string temp1(size - num1.size(), '0');
        num1 = temp1 + num1;
        string temp2(size - num2.size(), '0');
        num2 = temp2 + num2;
        //计算结果
        string res(size + 1, '0'); // 多申请一位  以免最高位有进位
        for(int i = size - 1; i >= 0; --i){
            int temp = (num1[i]-'0') + (num2[i]-'0') + (res[i+1]-'0');
            res[i+1] = (temp % 10) + '0';//当前的位
            res[i] = (temp / 10) + '0';//进位
        }
        //处理高位打头的'0'
        for(int i = 0; i < res.size(); ++i){
            if(res[i] != '0'){
                return res.substr(i);
            }
        }
        return "0";
    }
};


43. 字符串相乘
//竖式乘法: https://leetcode-cn.com/problems/multiply-strings/solution/c-shu-shi-cheng-fa-dai-ma-jian-ji-you-ya-yi-dong-b/
class Solution {
public:
    string multiply(string num1, string num2) {
        string res(num1.size() + num2.size(), '0');
        for(int i = num2.size() - 1; i >= 0; --i){
            for(int j = num1.size() - 1; j >= 0; --j){
                int temp = (res[i+j+1]-'0') + (num1[j]-'0') * (num2[i]-'0');
                res[i+j+1] = temp % 10 + '0';//当前位
                res[i+j] += temp / 10; //前一位加上进位，res[i+j]已经初始化为'0'，加上int类型自动转化为char，所以此处不加'0'
            }
        }
        //去除首位的'0'
        for(int i = 0; i < res.size(); ++i){
            if(res[i] != '0'){
                return res.substr(i);
            }
        }
        return "0";
    }
};









