// 312. 戳气球  回溯法 暴力超时
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int maxScore = 0;
        // 使用hash 便于搜索和删除  
        unordered_map<int, int> data; // idx  num
        data[-1] = 1;
        data[nums.size()] = 1;
        for (int i = 0; i < nums.size(); ++i) {
            data[i] = nums[i];
        }
        // 回溯
        backtrace(data, nums.size(), 0, maxScore);
        return maxScore;
    }

private:
    void backtrace(unordered_map<int, int>& data, int n, int score, int& maxScore) {
        if (data.size() == 2) {
            maxScore = max(maxScore, score);
            return;
        }

        for (int i = 0; i < n; ++i) {
            if (!data.count(i)) {
                continue;
            }
            // 戳破这个气球
            int num = data[i];
            data.erase(i);
            // 计算前后气球的下标和得分
            int prevIdx = i - 1;
            while (!data.count(prevIdx)) {
                --prevIdx;
            }
            int nextIdx = i + 1;
            while (!data.count(nextIdx)) {
                ++nextIdx;
            }
            int temp = score + data[prevIdx]*num*data[nextIdx];
            // 回溯
            backtrace(data, n, temp, maxScore);
            // 放回气球i
            data[i] = num;
        }
    }
    
};
