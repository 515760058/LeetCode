
79. 单词搜索
给定一个二维网格和一个单词，找出该单词是否存在于网格中。
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (word.empty()) {
            return true;
        }

        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[0].size(); ++j) {
                if (board[i][j] != word[0]) { 
                    continue;
                }
                // 首字母匹配上了，可以开始搜索一次
                vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
                bool found = false;
                backTrace(board, i, j, visited, word, 0, found); 
                if (found) {
                    return true;
                }
            }
        }
        return false;
    }

private:
    void backTrace(vector<vector<char>>& board, int i, int j, vector<vector<bool>>& visited, string& word, int idx, bool& found) {
        if (found) { // 以前已经找到了
            return;
        }
        if (idx == word.size()) { // 这次找到了！
            found = true;
            return;
        }
        // 校验下标
        int row = board.size();
        int col = board[0].size();
        if (i < 0 || i >= row || j < 0 || j >= col) {
            return;
        }
        // 已经访问过当前字符了 || 当前字符匹配不上  无法继续
        if (visited[i][j] || board[i][j] != word[idx]) {
            return;
        }
        // 当前字符匹配上了
        visited[i][j] = true;
        backTrace(board, i-1, j, visited, word, idx+1, found);
        backTrace(board, i+1, j, visited, word, idx+1, found);
        backTrace(board, i, j-1, visited, word, idx+1, found);
        backTrace(board, i, j+1, visited, word, idx+1, found); 
        visited[i][j] = false;
    }
};



剑指 Offer 13. 机器人的运动范围
class Solution {
private:
    struct Position {
        int x; 
        int y;
        Position(int _x, int _y) : x(_x), y(_y) {}
        string toString() {
            return to_string(x) + " " + to_string(y);
        }
    };
    // 向上走一步 向右走一步
    int dx[2] = {0, 1};
    int dy[2] = {1, 0};

    // x和y的数位之和
    int digitalSum(int x, int y) {
        int sum = 0;
        while (x || y) {
            sum += x % 10;
            sum += y % 10;
            x /= 10;
            y /= 10;
        }
        return sum;
    }

public:
    // BFS
    int movingCount(int m, int n, int k) {
        int cnt = 0;
        queue<Position> q;
        q.push(Position(0, 0));
        set<string> visited;
        visited.insert(Position(0, 0).toString());
        while (!q.empty()) {
            cnt++;
            Position p = q.front();
            q.pop();
            for (int i = 0; i < 2; ++i) {
                int nextX = p.x + dx[i];
                int nextY = p.y + dy[i];
                // 校验坐标
                if (nextX >= m || nextY >= n || digitalSum(nextX, nextY) > k) {
                    continue;
                }
                // 保存下一个(未访问过的)位置
                Position nextP(nextX, nextY);
                if (!visited.count(nextP.toString())) {
                    q.push(nextP);
                    visited.insert(nextP.toString());
                }
            }
        }
        return cnt;
    }
};



剑指 Offer 26. 树的子结构
class Solution {
public:
    // 双重递归
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (B == nullptr) {
            return false;
        }
        bool found = false;
        preOrder(A, B, found);
        return found;
    }

private:
    // 第一重递归  对A进行前序遍历 从A中找一个起始节点
    void preOrder(TreeNode* A, TreeNode* B, bool& found) {
        if (A == nullptr || found) {
            return;
        }
        if (A->val == B->val) {
            // 进入第二重递归, 判断子结构
            found = isSubStructureCore(A, B);
        }
        preOrder(A->left, B, found);
        preOrder(A->right, B, found);
    }
    // 第二重递归  判断子结构
    bool isSubStructureCore(TreeNode* A, TreeNode* B) {
        if (B == nullptr) {
            return true;
        }
        if (A == nullptr) { // 隐含:B不是null
            return false;
        }
        if (A->val != B->val) {
            return false;
        }
        // 当前节点相等 判断左右子树
        return isSubStructureCore(A->left, B->left) && isSubStructureCore(A->right, B->right);
    }
};



剑指 Offer 27. 二叉树的镜像
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        // 交换当前的左右子树指针
        swap(root->left, root->right);
        // 递归到下层
        mirrorTree(root->left);
        mirrorTree(root->right);
        return root;
    }
};




剑指 Offer 28. 对称的二叉树
class Solution {
private:
    bool isSymmetricCore(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right == nullptr) { // 两个都为null
            return true;
        }
        if (left == nullptr || right == nullptr) { // 一个为null 另一个不是null
            return false;
        }
        if (left->val != right->val) { // 两个都不为null
            return false;
        }
        return isSymmetricCore(left->left, right->right) && isSymmetricCore(left->right, right->left);
    }

public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        return isSymmetricCore(root->left, root->right);
    }
};


剑指 Offer 14- I. 剪绳子
class Solution {
public:
    int cuttingRope(int n) {
        if (n < 4) {
            return n - 1;
        }
        long res = 1;
        while (n > 4) {
            res = res * 3;
            n -= 3;
        }
        return res * n;
    }
};


剑指 Offer 14- II. 剪绳子 II
/*
核心思路是：尽可能把绳子分成长度为3的小段，这样乘积最大
步骤如下：
    (1)如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1
    (2)如果 n == 4，返回4
    (3)如果 n > 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段；每次乘法操作后记得取余就行
    以上2和3可以合并
*/
class Solution {
private:
    static const int MOD = 1000000007;
public:
    int cuttingRope(int n) {
        if (n < 4) {
            return n - 1;
        }
        long res = 1;
        while (n > 4) {
            res = res * 3 % MOD;
            n -= 3;
        }
        return res * n % MOD;
    }
};



