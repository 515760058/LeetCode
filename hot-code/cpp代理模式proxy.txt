代理模式简介
https://blog.csdn.net/sinat_21107433/article/details/102772697
“代理”这个词不陌生吧？买化妆品、买奶粉、买包包，都可以通过代理代购，甚至有专门的代购网站；在软件设计模式中，也有一种模式可以提供与代购网站类似的功能。
当客户端不能或者不便直接访问一个对象时，可以通过一个称为“代理”的第三方来间接访问，这样的设计模式称为代理模式。

代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
代理模式是一种对象结构型模式，在该模式中引入了一个代理对象，在客户端和目标访问对象之间起到中介的作用。
代理对象可以屏蔽或删除客户不想访问的内容和服务，也可以根据客户需求增加新的内容和服务。 


代理模式结构
代理模式的关键是代理类（Proxy）。代理模式中引入了抽象层，客户端针对抽象层编程，这样使得客户端可以一致对待真实对象和代理对象。
代理模式主要有抽象层（Subject）、代理对象（Proxy）和真实对象（RealSubject）组成：
    抽象层（Subject）：声明了代理对象和真实对象共同的一些接口，因此在任何可以使用真实对象的地方都可以使用代理对象，客户端通常针对抽象层进行编程；
    代理对象（Proxy）：代理对象通过关联关系引用真实对象，因此可以控制和操纵真实主题对象；
           代理对象中提供一个与真实主题角色相同的接口（以在需要时替代真实主题角色），同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能；
    真实对象（RealSubject）：真实对象是代理对象所代表的真实对象，提供真正的业务操作，客户端可以通过代理主题角色间接地调用真实对象中定义的操作。


代理模式代码实例：
在某应用软件中需要记录业务方法的调用日志，在不修改现有业务的基础上为每个类提供一个日志记录代理类，在代理类中输出日志。
例如在业务方法method()调用之前输出“方法method()被调用，调用时间为xxx”，调用之后输出“方法method()”调用成功。
在代理类中调用真实业务类的业务方法，使用代理模式设计该日志记录模块的结构。

#include <iostream>

using namespace std;

// 抽象层
class Subject {
public:
    virtual ~Subject() {}
    virtual void func() = 0; // 抽象层接口
};

// 真实对象  真正的实现业务
class RealSubject : public Subject {
public:
    virtual ~RealSubject(){}
    virtual void func() override { cout << "真正的业务方法" << endl; }
};


// 代理类
class Proxy : public Subject {
private:
    RealSubject* realSubject; // 操作一个真实对象
public:
    // 构造与析构
    Proxy(){ realSubject = new RealSubject(); }
    virtual ~Proxy(){ delete realSubject; }
    // 代理类中的业务方法
    virtual void func() override {
        preCallfunc(); // 事前做一些操作
        realSubject->func(); // 调用真正对象的业务方法
        postCallfunc(); // 事后做一些操作
    }
private:
    void preCallfunc() { cout << "方法func()被调用，调用时间为xxx" << endl; }
    void postCallfunc(){ cout << "方法func()调用结果x" << endl; }
};

// 客户端代码示例
int main() {
    // 不适用代理类，直接使用真实对象类
    Subject* subject = new RealSubject();
    subject->func();
    // 使用代理类，代理类额外的增加了一些功能
    Subject* subject1 = new Proxy();
    subject1->func();
    
    delete subject;
    delete subject1;

    return 0;
}







优点：
    代理模式能够协调调用者和被调用者，降低系统耦合度；
    客户端针对抽象主题角色编程，如果要增加或替换代理类，无需修改源代码，符合开闭原则，系统扩展性好；
    远程代理优点：为两个位于不同地址空间的对象的访问提供解决方案，可以将一些资源消耗较多的对象移至性能较好的计算机上，提高系统整体性能；
    虚拟代理优点：通过一个资源消耗较少的对象来代表一个消耗资源较多的对象，节省系统运行开销；
    缓冲代理优点：为某一个操作结果提供临时的存储空间，可以在后续操作中使用这些结果，缩短了执行时间；
    保护代理优点：:控制对一个对象的访问权限，为不同客户提供不同的访问权限。
缺点：
    增加了代理类和代理对象，增加了代理对象中的某些处理流程，可能会使得系统响应变慢；
    有的代理模式（如远程代理）实现代码较为复杂。
适用环境：
    当客户端对象需要访问远程主机中的对象——可以使用远程代理；
    当需要用一个资源消耗较少的对象来代表一个资源消耗较多的对象——虚拟代理；
    当需要限制不同用户对一个独享的访问权限——保护代理；
    当需要为一个频繁访问的操作结果提供临时存储空间——缓冲代理；
    当需要为一个对象的访问提供一些额外的操作——智能引用代理。
