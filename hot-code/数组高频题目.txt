33. 搜索旋转排序数组  ：    数组元素是唯一的
    二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段。
    我们观察上面红色加粗的数字都是升序的，由此我们可以观察出规律：
        如果中间的数小于最右边的数，则右半段是有序的
            判断target是否处于有序的右半段之中：如果是，就保留右边的区间；否则就保留左边的区间
        如果中间的数大于最右边的数，则左半段是有序的
            判断target是否处于有序的左半段之中：如果是，就保留左边的区间；否则就保留右边的区间
    我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) { // 找到 返回对应的下标
                return mid;
            }
            if (nums[mid] < nums[right]){ // 如果中间的数小于最右边的数，则右半段是有序的
                // 判断target是否处于有序的右半段之中：如果是，就保留右边的区间；否则就保留左边的区间
                if (nums[mid] < target &&  target <= nums[right]){ 
                    left = mid + 1;
                } else{
                    right = mid - 1;
                } 
            } else { // 若中间数大于最右边的数，则左半段是有序的
                // 判断target是否处于有序的左半段之中：如果是，就保留左边的区间；否则就保留右边的区间
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                } 
            }
        }
        return -1;
    }
};


81. 搜索旋转排序数组 II    数组中含有重复的元素
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) { // 找到了
                return true;
            }
            if (nums[mid] < nums[right]) { // 如果中间的数小于最右边的数，则右半段是有序的
                // 判断target是否处于有序的右半段之中：如果是，就保留右边的区间；否则就保留左边的区间
                if (nums[mid] < target &&  target <= nums[right]){ 
                    left = mid + 1;
                } else{
                    right = mid - 1;
                } 
            } else if (nums[mid] > nums[right]) { // 若中间数大于最右边的数，则左半段是有序的
                // 判断target是否处于有序的左半段之中：如果是，就保留左边的区间；否则就保留右边的区间
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else { // 和leetcode33题不一样的地方：nums[mid] == nums[right] 确定不了有序的区间，就修正一下right
                right--;
            }
        }
        return false;
    }
};

26. 删除有序数组中的重复项   （每个数字最多出现一次）
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int index = 0;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[index] != nums[i]) {
                nums[++index] = nums[i]; // 先++  index指向要覆盖的数字
            }
        }
        return index + 1;
    }
};



80. 删除排序数组中的重复项 II     （每个数字最多出现两次）
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() < 2) {
            return nums.size();
        }
        int index = 2;
        for (int i = 2; i < nums.size(); ++i) {
            if (nums[index-2] != nums[i]) {
                nums[index++] = nums[i];
            }
        }
        return index;
    }
};




442. 数组中重复的数字
给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现多次而其他元素出现一次。找到所有出现多次的元素。
你可以不用到任何额外空间并在O(n)时间复杂度
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for(int i = 0; i < nums.size(); ++i) {
            int idx = abs(nums[i]) - 1; // 使用abs消除负号的影响
            if (nums[idx] < 0) { // 如果这个idx加上负号了 说明对应的数字是重复出现了
                res.push_back(idx + 1); // 恢复原数字nums[i] = idx + 1
            }
            nums[idx] = -nums[idx]; // 加上负号
        }
        return res;
    }
};


645. 错误的集合（缺失和重复的元素）
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        // 找重复的
        int repet = -1;
        for (int i = 0; i < nums.size(); ++i) {
            int idx = abs(nums[i]) - 1;
            if (nums[idx] < 0) { // 已经出现过 记录重复数字
                repet = idx + 1;
            } else {
                nums[idx] = -nums[idx]; //第一次出现 加上负号  标记为已访问过
            }
        }
        // 找缺失的  缺失的数字  其转为下标后  
        int miss = -1;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > 0) {
                miss = i + 1;
                break;
            }
        }
        return {repet, miss};
    }
};




969. 煎饼排序
//按数字处理：
//  先把最大的数字弄到正确的位置：找到它的下标, 先翻到第一个位置，再翻到最后一个位置
//  再处理第二大的数字：找到它的下标, 先翻到第一个位置，再翻到倒数第二个位置
//  .....
class Solution {
public:
    vector<int> pancakeSort(vector<int>& A) {
        vector<int> res;
        for(int i = A.size(); i > 0; --i){ // 每次寻找最大的数字i
            int idx = max_element(A.begin(), A.begin()+i) - A.begin() + 1; // 数字i的下标+1  (下标从1开始计算)
            if(idx != i){ // 数字i的位置不正确：就先把数字i翻转到第一个数字 然后再把数字i翻转到(每轮操作)最后的位置
                //记录翻转操作
                res.push_back(idx);
                res.push_back(i);
                //对应操作数组
                reverse(A.begin(), A.begin() + idx);
                reverse(A.begin(), A.begin() + i);
            }
        }
        return res;
    }
};






