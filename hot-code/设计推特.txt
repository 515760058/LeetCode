355. 设计推特
class Twitter {
private:

    struct Message {
        int msg; // 推文内容
        int time; // 发布时间
        Message(int _msg, int _time) : msg(_msg), time(_time) {} // 构造函数
        bool operator< (const Message& m) const {
            return time < m.time;
        }
    };

    struct User {
        int id;             // 用户id
        set<int> followed;  // 该用户的关注列表
        list<Message> msgs; // 该用户发布的推文
        // 构造函数
        User () { }
        // 初始化
        void init(int _id) {
            id = _id;
            follow(_id); // 自己关注自己
        }
        // 关注userId
        void follow(int userId) {
            followed.insert(userId);
        }
        // 取关userId
        void unfollow(int userId) {
            followed.erase(userId);
        }
        // 发布推特
        void post(int msg, int time) {
            msgs.push_front( Message(msg, time) );
        }
    };
    
    int timestamp = 0;
    map<int, User> users; // 所有的用户  key:用户id  value:用户的信息

public:
    /** Initialize your data structure here. */
    Twitter() { }
    
    /** Compose a new tweet. */
    void postTweet(int userId, int tweetId) {
        if (!users.count(userId)) {
            users[userId] = User();
            users[userId].init(userId);
        }
        users[userId].post(tweetId, timestamp++);
    }
    
    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */
    vector<int> getNewsFeed(int userId) {
        vector<int> res;
        if (!users.count(userId)) {
            return res;
        }
        set<int>& foll = users[userId].followed; // 关注列表
        // 每个关注的用户 最多取10条推文 加入到优先队列中
        priority_queue<Message> pq;
        for (int id : foll) {
            list<Message>& msgs = users[id].msgs;
            auto iter = msgs.begin();
            for (int i = 0; i < 10 && iter != msgs.end(); ++i, ++iter) {
                pq.push(*iter);
            }
        }
        // 从优先队列中 取出10条推文
        for (int i = 0; i < 10 && (!pq.empty()); ++i) {
            res.push_back( pq.top().msg );
            pq.pop();
        }
        return res;
    }
    
    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */
    void follow(int followerId, int followeeId) {
        if (!users.count(followerId)) {
            return;
        }
        users[followerId].follow(followeeId);
    }
    
    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
    void unfollow(int followerId, int followeeId) {
        if (!users.count(followerId)) {
            return;
        }
        users[followerId].unfollow(followeeId);
    }
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter* obj = new Twitter();
 * obj->postTweet(userId,tweetId);
 * vector<int> param_2 = obj->getNewsFeed(userId);
 * obj->follow(followerId,followeeId);
 * obj->unfollow(followerId,followeeId);
 */