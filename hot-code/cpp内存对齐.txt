cpp 字节对齐
https://blog.csdn.net/sweetfather/article/details/78487563

https://blog.csdn.net/liukun321/article/details/6974282
【知乎专栏 https://zhuanlan.zhihu.com/p/26122273】



什么是字节对齐
    现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，
    但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放。

字节对齐的原因和作用
　　(1) 各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。
            比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况.
      (2) 但常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。
            比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，
             而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。

一：默认情况下的规则：
  在默认情况下，VC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。
  常用类型的对齐方式(vc6.0,32位系统)
    类型      对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
    char     偏移量必须为sizeof(char)即1的倍数 
    int        偏移量必须为sizeof(int)即4的倍数 
    float     偏移量必须为sizeof(float)即4的倍数 
    double 偏移量必须为sizeof(double)即8的倍数 
    short    偏移量必须为sizeof(short)即2的倍数 
 
  各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节VC会自动填充。
  同时VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 

举例
下面用前面的例子来说明VC到底怎么样来存放结构的。 
    struct MyStruct { 
        double dda1; 
        char dda; 
        int type 
    };
为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式，
(1)先为第一个成员dda1分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(double)的倍数），该成员变量占用sizeof(double)=8个字节；
(2)接下来为第二个成员dda分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，所以把dda存放在偏移量为8的地方满足对齐方式，该成员变量占用 sizeof(char)=1个字节；
(3)接下来为第三个成员type分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是sizeof (int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的(4)地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把type存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；
(5)这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。所以整个结构的大小为：sizeof(MyStruct)=8+1+ 3+4=16，其中有3个字节是VC自动填充的，没有放任何有意义的东西。 


再举个例子，交换一下上面的MyStruct的成员变量的位置，使它变成下面的情况： 
    struct MyStruct  { 
        char dda;　　　//偏移量为0，满足对齐方式，dda占用1个字节； 
        double dda1;　// 下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，
                               // dda1存放在偏移量为8的地址上，它占用8个字节。 
        int type；　　  //下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。 
    };　　　 　　　　 //所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，
                              //所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。 
所以该结构总的大小为：sizeof(MyStruc)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。 


二：指定字节对齐的规则
VC 中提供了#pragma pack(n)来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的偏移量有两种情况：
    (1)如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，
    (2)如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。
结构的总大小也有个约束条件，分下面两种情况：
    如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；
    否则必须为n的倍数（两者相比，取小。）

举例说明其用法
    #pragma pack(push)       　//保存对齐状态 
    #pragma pack(4)　　　　　//设定为4字节对齐 
        struct test { 
            char m1; 
            double m4; 
            int m3; 
        };
    #pragma pack(pop)　　　 //恢复对齐状态 
以上结构的大小为16，分析其存储情况:  
        首先为m1分配空间，其偏移量为0，满足我们自己设定的对齐方式（4字节对齐），m1占用1个字节。
        接着开始为 m4分配空间，这时其偏移量为1，需要补足3个字节，这样使偏移量满足为n=4的倍数（因为sizeof(double)大于n）,m4占用8个字节。
        接着为m3分配空间，这时其偏移量为12，满足为4的倍数，m3占用4个字节。
    这时已经为所有成员变量分配了空间，共分配了16个字节，满足为n的倍数。

如果把上面的#pragma pack(4)改为#pragma pack(16)，那么我们可以得到结构的大小为24。
        首先为m1分配空间，其偏移量为0，满足我们自己设定的对齐方式（4字节对齐），m1占用1个字节。
        接着开始为m4分配空间，这时其偏移量为1，需要先填充7个字节确保偏移量是8，然后m4占用8个字节
        接着为m3分配空间，这时其偏移量为16，满足为4的倍数，m3占用4个字节。
    这时已经为所有成员变量分配了空间，共分配了1+7+8+4=20个字节， 不满足8的倍数。因此后面还要补充4个字节。


复杂的例子
    #pragma pack(8)
        struct S1{
            char a;
            long b;
        };
        struct S2 {
            char c;
            struct S1 d;
            long long e;
        };
    #pragma pack()

sizeof(S2)结果为24.
　　成员对齐有一个重要的条件：即每个成员分别对齐.即每个成员按自己的方式对齐.也就是说上面虽然指定了按8字节对齐,但并不是所有的成员都是以8字节对齐.
                   其对齐的规则是,每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是8字节)中较小的一个对齐.
                   并且结构的长度必须为所用过的所有对齐参数的整数倍,不够就补空字节.
　　S1中,成员a是1字节默认按1字节对齐,指定对齐参数为8,这两个值中取1,a按1字节对齐;
              成员b是4个字节,默认是按4字节对齐,这时就按4字节对齐,所以sizeof(S1)应该为8;
　　S2 中,c和S1中的a一样,按1字节对齐,
              而d 是个结构,它是8个字节,它按什么对齐呢?对于结构来说,它的默认对齐方式就是它的所有成员使用的对齐参数中最大的一个,S1的就是4.所以,成员d就是按4字节对齐.
              成员e是8个字节,它是默认按8字节对齐,和指定的一样,所以它对到8字节的边界上,这时,已经使用了12个字节了,所以又添加了4个字节的空,从第16个字节开始放置成员e.
          这时,长度为24,已经可以被8(成员e按8字节对齐)整除.这样,一共使用了24个字节.

    S1的内存布局：1***,1111,
    S2的内存布局：1***,1***,1111,****11111111

这里有三点很重要:
    (1)每个成员分别按自己的方式对齐,并能最小化长度。
    (2)复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复杂类型时,可以最小化长度。
    (3)对齐后的长度必须是成员中最大的对齐参数的整数倍,这样在处理数组时可以保证每一项都边界对齐。

总结
    内存对齐计算方法：
        (1)看变量所在偏移地址是否为变量大小的整数倍
        (2)看对齐后的总大小是否为最长变量的整数倍

