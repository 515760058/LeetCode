228. 汇总区间 （简单）
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> res;
        int start = 0; // 起始下标
        while (start < nums.size()) {
            int end = findRange(nums, start); // 找一个结束下标
            if (start < end) {
                res.push_back( to_string(nums[start]) + "->" + to_string(nums[end]) );
            } else { // start == end
                res.push_back( to_string(nums[start]) );
            }
            start = end + 1;
        }
        return res;
    }

private:
    // 在nums中根据start, 找到连续区间的end
    int findRange(vector<int>& nums, int start) {
        int end = start + 1;
        while (end < nums.size()) {
            if (nums[start] + 1 != nums[end]) {
                break;
            }
            ++start;
            ++end;
        }
        return --end;
    }
};




452. 用最少数量的箭引爆气球
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if (points.empty()) {
            return 0;
        }
        // 按区间的终点升序排序
        sort(points.begin(), points.end(),
             [](vector<int>& l, vector<int>& r){
                 return l[1] < r[1];
             });
        // 统计不重叠的区间数量
        int cnt = 1; // 至少有一个不重叠的区间(需要一箭)
        int end = points[0][1];
        for (int i = 1; i < points.size(); ++i) {
            int nextStart = points[i][0];
            // 找到下一个完全不重叠的区间了
            if (nextStart > end) {
                ++cnt;
                end = points[i][1]; // 更新到下一个区间
            }
        }
        return cnt;
    }
};




435. 无重叠区间
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        // 按区间的终点升序排序
        sort(intervals.begin(), intervals.end(),
             [](vector<int>& l, vector<int>& r){
                 return l[1] < r[1];
             });
        // 统计不重叠的区间数量
        int cnt = 1; // 至少有一个不重叠的区间
        int end = intervals[0][1];
        for (int i = 1; i < intervals.size(); ++i) {
            // 找到下一个不重叠的区间了
            int nextStart = intervals[i][0];
            if (nextStart >= end) {
                ++cnt;
                end = intervals[i][1]; // 更新到下一个区间终点
            }
        }
        // 所有区间 减去 不重叠的区间 就是要移除的区间数量
        return intervals.size() - cnt;
    }
};




56. 合并区间
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if (intervals.empty()) {
            return res;
        }
        // 按区间的起始点 升序排序
        sort(intervals.begin(), intervals.end(),
            [](vector<int>& l, vector<int>& r) {
                return l[0] < r[0];
            });
        // 开始合并区间
        res.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); ++i) {
            auto& currInterval = intervals[i]; // 当前比较的区间
            auto& last = res.back(); // 上一个结果 可能还需要更新 （如果相交的区间有更大的end 就需要更新  也就是合并）
            if (currInterval[0] <= last[1]) { // 当前区间的start <= 上一个结果的end  因此需要合并
                last[1] = max(last[1], currInterval[1]); // 将end 更新为两个区间最大的end (合并了)
            } else { // 当前区间的start > 上一个结果的end  因此 两个区间不相连 是一个新的结果
                res.push_back(currInterval); // 处理下一个待合并的区间
            }
        }
        return res;
    }
};



57. 插入区间
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        // 把要插入的区间放进去 然后合并
        intervals.push_back(newInterval);
        return merge(intervals);
    }

private:
    // leetcode56 合并区间的代码
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if (intervals.empty()) {
            return res;
        }
        // 按区间的起始点 升序排序
        sort(intervals.begin(), intervals.end(),
            [](vector<int>& l, vector<int>& r) {
                return l[0] < r[0];
            });
        // 开始合并区间
        res.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); ++i) {
            auto& currInterval = intervals[i]; // 当前比较的区间
            auto& last = res.back(); // 上一个结果 可能还需要更新 （如果相交的区间有更大的end 就需要更新  也就是合并）
            if (currInterval[0] <= last[1]) { // 当前区间的start <= 上一个结果的end  因此需要合并
                last[1] = max(last[1], currInterval[1]); // 将end 更新为两个区间最大的end (合并了)
            } else { // 当前区间的start > 上一个结果的end  因此 两个区间不相连 是一个新的结果
                res.push_back(currInterval); // 处理下一个待合并的区间
            }
        }
        return res;
    }
};




1272. 删除区间
class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        res = []
        for i, j in intervals:                              //区间[i, j]
            if j <= toBeRemoved[0] or toBeRemoved[1] <= i:  //不相交：左边不相交 [i,j] [toBeRemoved] 或  右边不相交 [toBeRemoved] [i, j]
                res.append([i, j])                                   // 还是把[i, j]保存在结果中
            else:                                           // 相交的两种情况：左边相交 右边相交
                if toBeRemoved[0] > i:                      // i  toBeRemoved[0]  j  toBeRemoved[1]
                    res.append([i, toBeRemoved[0]])
                if toBeRemoved[1] < j:                      // toBeRemoved[0]  i  toBeRemoved[1]  j
                    res.append([toBeRemoved[1], j])
        return res
————————————————
版权声明：本文为CSDN博主「coordinate_blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_17550379/article/details/103342762





1288. 删除被覆盖区间
class Solution {
    /*
    对于区间覆盖问题，可以将区间按起点升序，终点降序的方式重新排列.
    重排列后，对于第i个区间[left_i, right_i)和第j个区间[left_j, right_j)，如果i < j，则必然有left_i <= left_j。    即，重排列后，如果发生区间覆盖，一定是前面的区间覆盖后面的区间。
    https://leetcode-cn.com/problems/remove-covered-intervals/solution/1288-shan-chu-bei-fu-gai-qu-jian-by-jue-nf0fb/
    */
public:
    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        // 排序
        sort(intervals.begin(), intervals.end(),
            [](vector<int>& l, vector<int>& r){
                // 先按起点升序
                if (l[0] != r[0]) {
                    return l[0] < r[0];
                }
                // 再按终点降序
                return l[1] > r[1];
            });
        //for (auto& interval : intervals) {
        //    cout << interval[0] << ", " << interval[1] << endl;
        //}
        // 排序后，只有三种情况：(1)前面的区间覆盖后面的区间 (2)前面的区间和后面的区间相交 (3)前面的区间和后面的区间无关
        int res = intervals.size();
        int currStart = intervals[0][0];
        int cnrrEnd = intervals[0][1];
        for (int i = 1; i < intervals.size(); ++i) {
            if (currStart <= intervals[i][0] && intervals[i][1] <= cnrrEnd) { // curr覆盖了intervals[i]
                res--; // 减去这个区间
            } else if (intervals[i][0] <= cnrrEnd && cnrrEnd <= intervals[i][1]) { // curr相交intervals[i]
                currStart = intervals[i][0];
                cnrrEnd = intervals[i][1];
            } else if (cnrrEnd < intervals[i][0]) { // curr和intervals[i]不相交， 直接更新到intervals[i]
                currStart = intervals[i][0];
                cnrrEnd = intervals[i][1];
            }
        }
        return res;
    }
};




986. 区间列表的交集
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {
        vector<vector<int>> res;
        // A和B中各取一个区间
        int i= 0;
        int j = 0;
        while (i < A.size() && j < B.size()) {
            int start = max(A[i][0], B[j][0]); // 两个区间左端点的大值作为起点
            int end = min(A[i][1], B[j][1]); // 两个区间右端点的小值作为终点
            // 满足相交的条件
            if (start <= end) {
                res.push_back( {start, end} );
            }
            // A或者B 更新至下一个区间：谁的end值小,谁就更新到下一区间
            if (A[i][1] < B[j][1]) {
                i++;
            } else {
                j++;
            }
        }
        return res;
    }
};
