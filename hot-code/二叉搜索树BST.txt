剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return nullptr;
        }
        // p,q都小于root，都在root的左子树上
        if (p->val < root->val && q->val < root->val) {
            return lowestCommonAncestor(root->left, p, q);
        }
        // p,q都大于root，都在root的右子树上
        if (p->val > root->val && q->val > root->val) {
            return lowestCommonAncestor(root->right, p, q);
        }
        // p,q等于root  或者 一个大于root一个小于root  此时root就是公共祖先
        return root;
    }
};





剑指 Offer 36. 二叉搜索树与双向链表
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if (root == nullptr) {
            return NULL;
        }   
        Node* head = nullptr; // head保存头结点
        Node* pre = nullptr;  // pre保存中序遍历过程中的上一个节点
        inOrder(root, head, pre);
        head->left = pre;     //最后pre指向最后一个节点
        pre->right = head;
        return head;
    }
    void inOrder(Node* root, Node*& head, Node*& pre) { // 注意是指针的引用
        if(root == NULL) {
            return;
        }

        inOrder(root->left, head, pre);
        if (pre == nullptr) { //说明当前是第一个节点，作为头结点 
            head = root;
        } else {
            root->left  = pre;
            pre->right = root;
        }
        pre = root;
        inOrder(root->right, head, pre);
    }
};



98. 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return validBST(root, LONG_MIN, LONG_MAX);
    }

private:
    bool validBST(TreeNode* root, long low, long high) {
        if (root == nullptr) {
            return true;
        }
        // 节点值不在[low, high]范围内
        if (root->val <= low || high <= root->val) {
            return false;
        }
        // 验证左右子树
        return validBST(root->left, low, root->val) &&
               validBST(root->right, root->val, high);
    }
};


1382. 将二叉搜索树变平衡 （重建BST）
给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。
 //  2 中序遍历 重建二叉树
class Solution {
public:
    TreeNode* balanceBST(TreeNode* root) {
        vector<int> seq;
        inOrder(root, seq);
        return build(seq, 0, seq.size()-1);
    }

private:
    // 中序遍历获得BST的序列
    void inOrder(TreeNode* root, vector<int>& seq) {
        if (root == nullptr) {
            return;
        }
        inOrder(root->left, seq);
        seq.push_back(root->val);
        inOrder(root->right, seq);
    }

    // 根据中序序列  重建二叉树
    TreeNode* build(vector<int>& seq, int start, int end) {
        if (start > end) {
            return nullptr;
        }
        int mid = (start + end) >> 1;
        TreeNode* root = new TreeNode(seq[mid]); // 序列中间的数 是根节点
        root->left  = build(seq, start, mid-1);  // 构建左子树  根节点左边的序列
        root->right = build(seq, mid+1, end);    // 构建右子树  根节点右边的序列
        return root;
    }
};



剑指 Offer 33. 二叉搜索树的后序遍历序列
给定一个序列 判断该序列是否可能是BST的后序遍历结果。
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        if (postorder.empty()) {
            return true;
        }
        return verifyPostorder(postorder, 0, postorder.size()-1);
    }
private:
    // 验证[start, end]区间是否符合后序
    bool verifyPostorder(vector<int>& postorder, int start, int end) {
        if (start >= end) {
            return true;
        }
        // 根节点   后序遍历 最后一个是根节点
        int root = postorder[end];
        // 找左子树的节点: 小于等于根
        int mid = start;
        while (mid < end) {
            if (postorder[mid] > root) {
                break;
            }
            mid++;
        }
        // 左子树[start, mid-1]都小于等于根   所以右子树[mid, end-1]都要大于根！
        for (int i = mid; i < end; ++i) {
            if (postorder[i] <= root) {
                return false;
            }
        }
        // 继续验证左右子树
        return verifyPostorder(postorder, start, mid-1) && verifyPostorder(postorder, mid, end-1);
    }
};


99. 恢复二叉搜索树
给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
/*
我们对错误的二叉树进行 中序遍历 那我们按顺序访问到的数应该是按顺序排列的 
那如果对两个节点交换了顺序  那一定有两个地方是  不满足  前一个元素 < 当前元素 < 后一个元素
 如示例2      3  1  4   2：
              3  这个节点不满足      1 这个节点不满足
             所以我们使用两个全局变量在遍历过程中记录这两个节点 最后对他们进行交换
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode* t1 = nullptr;
        TreeNode* t2 = nullptr;
        TreeNode* pre = nullptr;
        // 中序
        inorder(root, t1, t2, pre);
        swap(t1->val, t2->val); // 交换
    }

private:
    void inorder(TreeNode* root, TreeNode*& t1, TreeNode*& t2, TreeNode*& pre){
        if (root == nullptr) {
            return;
        }
        inorder(root->left, t1, t2, pre);
        // 发现pre大于当前元素  不满足条件
        if (pre != nullptr && pre->val > root->val) { 
            if (t1 == nullptr) { // 第一个错误位置t1是pre
                t1 = pre;
            }
            t2 = root; // 第二个错误位置t2是第二次的当前节点
        }
        pre = root; // 更新pre
        inorder(root->right, t1, t2, pre);
    }
};


669. 修剪二叉搜索树
给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。
通过修剪二叉搜索树，使得所有节点的值在[low, high]中。
修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) {
            return nullptr;
        }
        // 当前节点小于low 只能寄希望于右子树(比当前节点大)是否存在符合条件的
        if (root->val < low) {
            return trimBST(root->right, low, high);
        }
        // 当前节点大于high 只能寄希望于左子树(比当前节点小)是否存在符合条件的
        if (root->val > high) {
            return trimBST(root->left, low, high);
        }
        // 当前节点在[low, high]范围内 左右子树都有可能符合条件
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};



701. 向二叉搜索树中插入节点
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) { // 当前就是插入点
            return new TreeNode(val);
        }
        if (val < root->val) { // 插入到左子树
            root->left = insertIntoBST(root->left, val);
        } else if (val > root->val) { // 插入到右子树
            root->right = insertIntoBST(root->right, val);
        }
        return root;
    }
};


450. 删除二叉搜索树中的节点
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) {
            return nullptr;
        }
        if (key < root->val) { // 待删除节点在左子树中
            root->left = deleteNode(root->left, key);
        } else if (key > root->val) { // 待删除节点在右子树中
            root->right = deleteNode(root->right, key);
        } else { // key == root.val   root就是待删除节点
            // root只有一个子树  返回另一个子树作为新的根
            if (root->left == nullptr) {  return root->right; }
            if (root->right == nullptr) { return root->left; }
            // root的左右子树都存在， 把（右子树的最左叶子）作为新的根
            TreeNode* minNode = getMin(root->right);
            root->val = minNode->val;
            // 在右子树中 删除新的根
            root->right = deleteNode(root->right, minNode->val);
        }
        return root;
    }

private:
    // BST最左边的节点 就是最小的
    TreeNode* getMin(TreeNode* node) {
        while (node->left != nullptr) {
            node = node->left;
        }
        return node;
    }
};


