322. 零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
你可以认为每种硬币的数量是无限的。

// dp[i]表示 金额为i时，需要的最少硬币数量
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1, amount+1);
        dp[0] = 0; // 0元钱 需要0个硬币
        for (int i = 0; i < dp.size(); ++i) {
            // 计算dp[i] 需要的最少硬币数量
            for (int coin : coins) {
                if (i >= coin) {
                    dp[i] = min(dp[i], dp[i-coin]+1);
                }
            }
        }
        if (dp[amount] == amount+1) {
            return -1;
        }
        return dp[amount];
    }
};



322. 零钱兑换
// 递归 + 备忘录   不推荐
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        unordered_map<int, int> mem;
        return helper(coins, amount, mem);
    }

private:
    int helper(vector<int>& coins, int amount, unordered_map<int, int>& mem) {
        if (amount < 0) { // 该子问题无解
            return -1;
        }
        if (amount == 0) { // 该子问题恰好解决
            return 0;
        }
        if (mem.count(amount)) { // 以前解决过该子问题,直接使用结果
            return mem[amount];
        }
        // 递归下去 查找amount对应的最优解
        long res = INT_MAX;
        for (int coin : coins) {
            long num = helper(coins, amount-coin, mem);
            if (num != -1) {
                res = min(res, num + 1);
            }
        }
        // 保存中间结果
        mem[amount] = (res == INT_MAX ? -1 : res); // 如果res == INT_MAX 说明子问题都无解，所以amount也对应无解
        return mem[amount];
    }
};




518. 零钱兑换 II   完全背包：每种物品有无限个
给定不同面额的硬币coins和一个总金额amount。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
// dp  推荐
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        // dp[i][j] 表示 只是用前i中面额 可以凑成金额j  的组合数
        vector<vector<int>> dp(n+1, vector<int>(amount+1, 0));
        // 初始态： 金额j为0时 有一种组合方案
        for (int i = 0; i <= n; ++i) {
            dp[i][0] = 1;
        }
        // 开始dp
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= amount; ++j){
                if(j >= coins[i-1]){
                    dp[i][j] =   dp[i-1][j]   // 不适用第i种面额凑成金额j 的组合数
                               + dp[i][j-coins[i-1]]; // 使用第i种面额凑成j-coins[i-1] 的组合数 （注意还是i 因为是完全背包 每种金额无限使用）
                } else {
                    dp[i][j] = dp[i-1][j]; // 金额j小于面额coins[i-1]  
                }
            }
        }
        return dp[n][amount];
    }
};


518. 零钱兑换 II
// 暴力递归法 超时
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        set<vector<int>> res;
        vector<int> temp;
        helper(amount, coins, temp, res);
        return res.size();
    }

private:
    void helper(int amount, vector<int>& coins, vector<int> temp, set<vector<int>>& res) {
        if (amount < 0) {
            return;
        }
        if (amount == 0) { // 有一个可行的组合方案
            sort(temp.begin(), temp.end()); // 排序后放入集合中去重
            res.insert(temp);
            return;
        }
        for (int coin : coins) {
            temp.push_back(coin);
            helper(amount-coin, coins, temp, res);
            temp.pop_back();
        }
    }
};

