141. 环形链表 判断链表是否有环
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            fast = fast->next->next; // 快指针每次走两步
            slow = slow->next;       // 慢指针每次走一步
            if (fast == slow) {      // 快慢指针相遇，就是有环
                return true;
            }
        }
        return false;
    }
};

class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> s; // 保存节点的地址
        while (head != nullptr) {
            if (s.count(head)) {   // 发现以前的节点
                return true;
            }
            s.insert(head);
            head = head->next;
        }
        return false;
    }
};



142. 环形链表 II    寻找环形链表的第一个节点
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            fast = fast->next->next; // 快指针每次走两步
            slow = slow->next;       // 慢指针每次走一步
            if (fast == slow) {      // 快慢指针相遇 存在环
                // 一定会在环的入口点相遇
                ListNode* slow2 = head; // 再定义一个慢指针 两个慢指针每次走一步 必定会在入口点相遇
                while (slow2 != slow) {
                    slow2 = slow2->next;
                    slow = slow->next;
                }
                return slow2;
            }
        }
        return nullptr;
    }
};

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode*> s; // 保存节点的地址
        while (head != nullptr) {
            if (s.count(head)) {   // 第一次发现以前的节点 就是入口节点
                return head;
            }
            s.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};



剑指 Offer 24. 反转链表 （全部节点）
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //借助栈
        stack<int> s;
        ListNode* p = head;
        while (p != nullptr) {
            s.push(p->val);
            p = p->next;
        }
        p = head;
        while (p != nullptr) {
            p->val = s.top();
            s.pop();
            p = p->next;
        }
        return head;
    }
};

// 迭代
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr; // 前一个节点
        ListNode* cur = head;    // 当前节点
        ListNode* temp = nullptr;

        while (cur != nullptr) {
            temp = cur->next; // 临时保存下一个节点
            cur->next = pre; // 当前节点 指向 前一个节点
            // 向后移动
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};


class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return reverseBetween(head, nullptr);
    }
private:
    // 反转链表的[head, tail)区间
    ListNode* reverseBetween(ListNode* head, ListNode* tail) {
        ListNode* pre = nullptr; // 前一个节点
        ListNode* cur = head;    // 当前节点
        ListNode* temp = nullptr;
        
        while (cur != tail) {
            temp = cur->next; // 临时保存下一个节点
            cur->next = pre; // 当前节点 指向 前一个节点
            // 向后移动
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};


92. 反转链表 II   （反转从位置 m 到 n 的链表） 一趟扫描
输入: 1->2->3->4->5->NULL, m = 2, n = 4     1 ≤ m ≤ n ≤ 链表长度。
输出: 1->4->3->2->5->NULL
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        // 创建一个虚拟节点 放在链表头部
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        // 走过前面的节点
        ListNode* pre = dummy;
        for (int i = 1; i < left; ++i) {
            pre = pre->next;
        }

        head = pre->next;
        for (int i = left; i < right; ++i) {
            ListNode* temp = head->next; // 临时保存下一个节点
            head->next = temp->next;
            temp->next = pre->next;
            pre->next = temp;
        }
        // 返回头结点
        head = dummy->next;
        delete dummy;
        return head;
    }
};
方法二：
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        // 创建一个虚拟节点 放在链表头部
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* preHead = dummy;
        for (int i = 1; i < left; ++i) {
            preHead = preHead->next;
        }
        ListNode* tmpHead = preHead->next;
        ListNode* tmpTail = tmpHead;
        for (int i = left; i <= right; ++i) {
            tmpTail = tmpTail->next;
        }
        // 反转后 接到前面
        preHead->next = reverseBetween(tmpHead, tmpTail);
        // 后面的接上
        tmpHead->next = tmpTail;
        // 返回头结点
        head = dummy->next;
        delete dummy;
        return head;
    }
private:
    // 借助上一题的函数
    // 反转链表的[head, tail)区间
    ListNode* reverseBetween(ListNode* head, ListNode* tail) {
        ListNode* pre = nullptr; // 前一个节点
        ListNode* cur = head;    // 当前节点
        ListNode* temp = nullptr;
        
        while (cur != tail) {
            temp = cur->next; // 临时保存下一个节点
            cur->next = pre; // 当前节点 指向 前一个节点
            // 向后移动
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};




剑指 Offer 25. 合并两个排序的链表  （归并排序链表）
// 迭代版本
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(-1);
        ListNode* pre = dummy;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                pre->next = l1;
                pre = pre->next;
                l1 = l1->next;
            } else {
                pre->next = l2;
                pre = pre->next;
                l2 = l2->next;
            }
        }
        // 某一条链表先结束了 判断还剩下哪一条
        if (l1 != nullptr) {
            pre->next = l1;
        }
        if (l2 != nullptr) {
            pre->next = l2;
        }
        // 返回头节点dummy->next
        pre = dummy->next;
        delete dummy;
        return pre;
    }
};

// 递归版本
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr){
            return l2;
        }
        if (l2 == nullptr){
            return l1;
        }

        if (l1->val > l2->val){
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        } else {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
    }
};





23. 合并K个升序链表
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) {
            return nullptr;
        }
        ListNode* result = lists[0];
        // result依次和lists[i]进行两两合并
        for (int i = 1; i < lists.size(); ++i) {
            result = mergeTwoLists(result, lists[i]);
        }
        return result;
    }

private:
    // 剑指 Offer 25. 合并两个排序的链表  （归并排序链表）
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(-1);
        ListNode* pre = dummy;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                pre->next = l1;
                pre = pre->next;
                l1 = l1->next;
            } else {
                pre->next = l2;
                pre = pre->next;
                l2 = l2->next;
            }
        }
        // 某一条链表先结束了 判断还剩下哪一条
        if (l1 != nullptr) {
            pre->next = l1;
        }
        if (l2 != nullptr) {
            pre->next = l2;
        }
        // 返回头节点dummy->next
        pre = dummy->next;
        delete dummy;
        return pre;
    }
};





25. K 个一组翻转链表
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (head == nullptr) {
            return head;
        }
        // 区间[a, b)包含K个待反转的节点
        ListNode* a = head;
        ListNode* b = head;
        for (int i = 0; i < k; ++i) {
            // 不足k个元素，不用反转
            if (b == nullptr) {
                return head;
            }
            b = b->next;
        }
        // 反转这k个节点
        ListNode* tmpHead = reverseBetween(a, b);
        // 此时a是尾节点了  指向后面的元素
        // 而b就后面元素的头结点  递归下去
        a->next = reverseKGroup(b, k);
        // 返回头结点
        return tmpHead;
    }

private:
    // 借助上一题的函数
    // 反转链表的[head, tail)区间
    ListNode* reverseBetween(ListNode* head, ListNode* tail) {
        ListNode* pre = nullptr; // 前一个节点
        ListNode* cur = head;    // 当前节点
        ListNode* temp = nullptr;
        
        while (cur != tail) {
            temp = cur->next; // 临时保存下一个节点
            cur->next = pre; // 当前节点 指向 前一个节点
            // 向后移动
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};



83. 删除排序链表中的重复元素
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
class Solution {
public:
    // 和 leetcode26删除有序数组中的重复项 原理相同
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == nullptr) {
            return head;
        }
        ListNode* myhead = head;
        ListNode* idx = head; //作为下标使用
        while (myhead->next) {
            if (idx->val != myhead->next->val) {
                idx = idx->next; //下标加1的操作
                idx->val = myhead->next->val;
            }
            myhead = myhead->next;
        }
        idx->next = NULL; // 断开后续节点
        return head;
    }
};



82. 删除排序链表中的重复元素 II
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        // 两个指针prev和cur
        ListNode* prev = dummy;
        ListNode* cur = head;
        while (cur) {
            bool duplicated = false;
            while (cur->next && cur->val == cur->next->val) { // cur的值和cur->next值相等
                duplicated = true;
                // 删除当前节点cur
                ListNode* tmp = cur;
                cur = cur->next;
                delete tmp;
            }
            if (duplicated) { // 删除重复的最后一个元素
                ListNode* tmp = cur;
                cur = cur->next;
            } else {
                // 连上
                prev->next = cur;
                // 向后走一个节点
                prev= prev->next;
                cur = cur->next;
            }
        }
        prev->next = nullptr;
        // 返回
        head = dummy->next;
        delete dummy;
        return head;
    }
};




234. 判断链表是否回文
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return true;
        }
        // 快慢指针 找到链表的中间节点slow
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        //cout << slow->val << endl;  // 1234指向3   123指向2

        // 翻转 后半段链表
        ListNode* half = nullptr;
        int len = getListLen(head); // 链表的长度
        if (len & 0x1) { // 奇数
            half = reverseList(slow->next);
        } else {
            half = reverseList(slow);
        }

        // 判断是否回文
        while (head && half) {
            if (head->val != half->val) {
                return false;
            }
            head = head->next;
            half = half->next;
        }
        return true;
    }

private:
    // 链表长度
    int getListLen(ListNode* head) {
        int len = 0;
        while (head) {
            len++;
            head = head->next;
        }
        return len;
    }

    // 翻转链表
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr; // 前一个节点
        ListNode* cur = head;    // 当前节点
        ListNode* temp = nullptr;

        while (cur != nullptr) {
            temp = cur->next; // 临时保存下一个节点
            cur->next = pre; // 当前节点 指向 前一个节点
            // 向后移动
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};




61. 旋转链表
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr || k == 0) {
            return head;
        }
        // 求长度 同时得出尾节点tmp
        ListNode* tmp = head;
        int len = 1;
        while (tmp->next) {
            len++;
            tmp = tmp->next;
        }
        k = len - k % len; // 新的k   从尾节点向后跑k步

        tmp->next = head; // 首位相连 形成环
        // 从原来的尾节点 继续向后跑k步
        for (int step = 0; step < k; ++step) {
            tmp = tmp->next;
        }
        head = tmp->next; // 新的首节点
        tmp->next = nullptr; // 断开环
        return head;
    }
};




148. 排序链表  sort
// 使用归并排序  nlogn
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        // 快慢指针找中间节点slow
        ListNode* fast = head;
        ListNode* slow = head;
        while ((fast->next) && (fast->next->next)) {
            slow = slow->next;
            fast = fast->next->next;
        }
        //cout << slow->val << ", " << fast->val << endl;
        // 从中间节点slow 断开
        fast = slow->next; // fast指向后半段
        slow->next = nullptr; // 前半段和后半段 断开
        // 递归的排序
        ListNode* l1 = sortList(head);
        ListNode* l2 = sortList(fast);
        return mergeTwoSortedList(l1, l2); // 归并排序
    }

private:
    // 归并 两个有序链表
    ListNode* mergeTwoSortedList(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(-1);
        ListNode* pre = dummy;
        while (l1 && l2) {
            if (l1->val <= l2->val) {
                pre->next = l1;
                pre = pre->next;
                l1 = l1->next;
            } else {
                pre->next = l2;
                pre = pre->next;
                l2 = l2->next;
            }
        }
        // 某一条链表先结束了 判断还剩下哪一条
        if (l1 != nullptr) {
            pre->next = l1;
        }
        if (l2 != nullptr) {
            pre->next = l2;
        }
        // 返回头节点dummy->next
        pre = dummy->next;
        delete dummy;
        return pre;
    }
};


