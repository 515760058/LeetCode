//回溯法 + DFS
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));//是否使用过该字符
        bool found = false;
        for(int i = 0; i < board.size(); ++i){
            for(int j = 0; j < board[0].size(); ++j){
                helper(i, j, 0, word, visited, board, found);
                if(found){
                    return true;
                }
            }
        }
        return false;
    }

private:
    //i, j：当前字符在board中的下标    idx：word数组中当前字符的下标
    void helper(int i, int j, int idx, string& word, vector<vector<bool>>& visited, vector<vector<char>>& board, bool& found){
        if(idx == word.size()){//匹配到word的最后一个字母了
            found = true;
            return;
        }
        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size()){//索引越界
            return;
        }
        if(found || visited[i][j] || board[i][j] != word[idx]){//已找到 或 已使用过该字符 或 该字符不匹配
            return;
        }
        //当前字符匹配上了，往其他方向搜索
        visited[i][j] = true;//标记使用
        helper(i-1, j, idx+1, word, visited, board, found);
        helper(i+1, j, idx+1, word, visited, board, found);
        helper(i, j-1, idx+1, word, visited, board, found);
        helper(i, j+1, idx+1, word, visited, board, found);
        visited[i][j] = false;//取消标记
    }
};